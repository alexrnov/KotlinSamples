package coroutines
import kotlinx.coroutines.*
import kotlin.concurrent.thread

object CoroutinesBasicSample {
  @JvmStatic
  fun main(args: Array<String>) {
    GlobalScope.launch { // запустить новую сопрограмму в фоновом режиме и продолжить
      // неблокирующая задержка на 1 секунду (единица времени по умолчанию - мс)
      // не блокирует поток а приостанавливает сопрограмму
      delay(1000L)
      println("World") // print after delay
    }
    println("Hello, ") // основной поток продолжается, пока сопрограмма задерживается
    // блокировать основной поток на 2 секунды, чтобы поддерживать JVM
    // и выполнить код в GlobalScope.launch {}, т.к. время жизни сопрограммы
    // ограничено только временем жизни всего приложения
    Thread.sleep(2000L)

    thread {
      //delay(1000L) // функция delay() доступна только в сопрограмме GlobalScope.launch { }
    }

    println("----------------------")
    // при таком смешивании delay() и Thread.sleep() как в примере выше легко
    // потерять кто блокирует а кто нет. Поэтому давайте подробно расскажем
    // о блокировке с использованием компоновщика сопрограмм runBlocking
    GlobalScope.launch { // запустить новую сопрограмму в фоновом режиме и продолжить
      delay(1000L)
      println("World")
    }
    println("Hello, ") // основной поток продолжается здесь немедленно
    runBlocking {
      // но это выражение блокирует основной поток
      delay(2000L) // мы задерживаемся на 2 секунды, чтобы поддержать JVM
    }
  }
}