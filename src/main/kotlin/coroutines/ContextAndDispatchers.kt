package coroutines


import kotlinx.coroutines.*

const val DEBUG_PROPERTY_NAME: String = "-ea"
// Сопрограммы всегда выполняются в некотором контексте, представленном
// значением типа CoroutineContext, определенного в стандартной библиотеке
// Kotlin. Контекст сопрограммы представляет собой набор различных элементов.
// Основными элементами являются Job сопрограммы, которую мы видели ранее,
// и ее диспетчер, который рассматривается в этом разделе.
object ContextSamples {
  @JvmStatic
  fun main(args: Array<String>) {
    println("f1(): ")
    // Диспетчеры и темы. Контекст сопрограммы включает диспетчер сопрограмм
    // (см. CoroutineDispatcher), который определяет, какой поток или потоки использует
    // соответствующая сопрограмма для своего выполнения. Диспетчер сопрограмм
    // может ограничить выполнение сопрограммы конкретным потоком, отправить его
    // в пул потоков или разрешить запуск без ограничений. Все компиляторы сопрограмм,
    // такие как launch и async, принимают необязательный параметр CoroutineContext,
    // который можно использовать для явного указания диспетчера для новой сопрограммы
    // и других элементов контекста.
    fun f1() = runBlocking {
      // наследует контекст главной сопрограммы runBlocking, которая выполняется в основном потоке.
      launch { // context of the parent, main runBlocking coroutine
        println("main runBlocking: I'm working in thread: ${Thread.currentThread().name}")
      }
      // Dispatchers.Unconfined - это специальный диспетчер, который также запускается в основном потоке,
      // но на самом деле это другой механизм, который будет объяснен позже.
      launch(Dispatchers.Unconfined) { // не ограничен - будет работать с основным потоком
        println("Unconfined: I'm working in thread: ${Thread.currentThread().name}")
      }
      // Диспетчер по умолчанию, который используется при запуске сопрограмм
      // в GlobalScope, представлен Dispatchers.Default и использует общий фоновый
      // пул потоков, поэтому для запуска (Dispatchers.Default) {...} используется тот
      // же диспетчер, что и GlobalScope.launch {.. .}.
      launch(Dispatchers.Default) { // будет отправлен в DefaultDispatcher
        println("Default: I'm working in thread: ${Thread.currentThread().name}")
      }
      // newSingleThreadContext создает поток для запуска сопрограммы. Выделенная
      // нить - очень дорогой ресурс. В реальном приложении оно должно быть либо
      // освобождено, когда оно больше не требуется, с использованием функции close,
      // либо сохранено в переменной верхнего уровня и повторно использовано во всем приложении.
      launch(newSingleThreadContext("MyOwnThread")) { // получит свою новую тему
        println("newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}")
      }
    }
    f1()
    println("----------------------------")
    println("f2(): ")
    // ограниченные и неограниченные диспетчеры.
    // Диспетчер неопределяемых сопрограмм Dispatchers.Unconfined запускает
    // сопрограмму в потоке вызывающей стороны, но только до первой точки приостановки.
    // После приостановки это возобновляет сопрограмму в потоке, который
    // полностью определен вызывающей функцией, которая была вызвана.
    // Неограниченный диспетчер подходит для сопрограмм, которые не
    // потребляют процессорное время и не обновляют какие-либо общие данные
    // (например, пользовательский интерфейс), ограниченные конкретным потоком.

    // С другой стороны, диспетчер наследуется от внешнего CoroutineScope по умолчанию.
    // Диспетчер по умолчанию для сопрограммы runBlocking, в частности, ограничен потоком-инициатором,
    // поэтому его наследование приводит к ограничению выполнения этого потока с помощью
    // предсказуемого планирования FIFO.
    fun f2() = runBlocking {
      launch(Dispatchers.Unconfined) { // не ограничен - будет работать с основным потоком
        println("Unconfined: I'm working in thread ${Thread.currentThread().name}")
        delay(500L)
        println("Unconfined: After delay in thread ${Thread.currentThread().name}")
      }
      launch {
        println("main runBlocking: I'm working in thread ${Thread.currentThread().name}")
        delay(500L)
        println("main runBlocking: After delay in thread ${Thread.currentThread().name}")
      }
    }
    // Таким образом, сопрограмма с контекстом, унаследованным от runBlocking {...},
    // продолжает выполняться в главном потоке, в то время как неограниченная
    // возобновляется в потоке исполнителя по умолчанию, который использует функция задержки.
    // Неограниченный диспетчер является продвинутым механизмом, который может
    // быть полезен в определенных угловых случаях, когда отправка сопрограммы для ее выполнения
    // позже не требуется или приводит к нежелательным побочным эффектам, потому что некоторая
    // операция в сопрограмме должна быть выполнена
    f2()
    println("---------------------")
    println("f3(): ")
    fun f3() = runBlocking<Unit> {
      val a = async {
        log("Я вычисляю часть ответа")
        6
      }
      val b = async {
        log("Я вычисляю другую часть ответа")
        7
      }
      log("The answer is ${a.await() * b.await()}")
    }
    f3()
    println("-------------------------")
  }



}

fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")