package functionsAndLambdas

object FunctionSamples {

  @JvmStatic
  fun main(args: Array<String>) {
    val class2F = Class2F()
    println("дефолтные параметры: ")
    class2F.f1("1", "4")
    class2F.f1("1")
    // когда первый параметр дефолтный, второй записывается как
    // именованный аргумент
    class2F.f2(s2 = "6")
    //дефолтные параметры с параметром-лямбдой
    class2F.f3("7") { println("f3_1: w()")} // первый дефолтный параметр изменен
    class2F.f3("8", "9") {println("f3_2: w()")} // оба дефолтных параметра изменены
    class2F.f3("8", "9", f = {println("f3_3: w()")} ) // оба дефолтных параметра изменены
    class2F.f3(f = { println("f3_4: w()") })  // дефолтные параметры не изменены
    class2F.f3 { println("f3_5: w()") } // дефолтные параметры не изменены
    println("-----------------------")
    println("Именованные аргументы: ")
    class2F.f4("s1", true, false, false, '_')
    // использование именованных аргументов. Именованные аргументы
    // делают код более читабильным
    class2F.f4(str = "s2", b1 = true, b2 = false, b3 = false, c = '_')
    // если нужно изменить только некоторые параметры
    class2F.f4(str = "s3", b2 = true)
    class2F.f4(str = "s4", b3 = true)
    // позиционный аргумент должен предшествовать именованному аргументу
    class2F.f5("7", s2 = "8")
    //class2F.f5(s1 = "7", "8") // нельзя
    class2F.f6("a", "b", "c", "d")
    // переменное количество аргументов с использованием именованного
    // аргумента может быть передано с помощью spread оператора
    class2F.f6(s = *arrayOf("a", "b", "c"))

    // функция с одиночным выражением может быть определена без скобок
    fun int1(x: Int): Int = x + x
    // если возвращаемый тип может быть выведен компилятором, он может
    // быть опущен. Это возможно только для однострочной функии
    fun int2(x: Int) = x + x
    println("-----------------------")
    println("vararg:")
    // передать переменное количество аргументов любого типа
    val list1 = class2F.asList("1", "2", "3")
    // если мы уже имеем массив и хотим передать его содержимое в
    // функцию, используется spread оператор *
    val a = arrayOf(1, 2, 3, 4, 5)
    val list2 = class2F.asList(*a)
    println("list1 = $list1")
    println("list2 = $list2")
    println("-----------------------")
    println("infix: ")
    var s =class2F.f8("d1")
    println("s1 = $s")
    // использование infix оператора позволяет записать выражение
    // без точек. Аналогично записи class2F.f8("d")
    s = class2F f8 "d1"
    println("s2 = $s")
    class2F.f9()
    println("-----------------------")
    println("Локальная функция: ")
    class2F.f10()
    println("-----------------------")
    class2F.f11(false)
  }
}

open class Class1F {
  /**
   * В параметрах функций и конструкторов может использоваться параметр
   * со значением по умолчанию. Это позволяет уменьшит количество
   * перегрузок конструкторов и функций
   */
  open fun f1(s1: String, s2: String = "5") {
    println("f1: s1 = $s1, s2 = $s2")
  }
}

class Class2F: Class1F() {
  /**
   * При переопределении метода дефолтное значение не указывается,
   * поскольку оно уже определено в супер-классе
   */
  override fun f1(s1: String, s2: String) {
    println("f1: s1 = $s1, s2 = $s2")
  }

  /**
   * Если дефолтный параметр предшествует обычному параметру,
   * значение по умолчанию можно использовать только при вызове
   * функции с именованными аргументами
   */
  fun f2(s1: String = "5", s2: String) {
    println("classesAndObjects.f2: s1 = $s1, s2 = $s2")
  }

  // если последний аргумент после дефолтных параметров является
  // лямбдой, его можно передать как именованный аргумент или вне скобок
  fun f3(s1: String = "5", s2: String = "6", f: () -> Unit) {
    println("classesAndObjects.f3: s1 = $s1, s2 = $s2")
    f.invoke()
  }

  /**
   * Паратметры функции могут быть проименованы при вызове функции.
   * Это очень удобно, когда функция имеет большое количество параметров
   * или параметров по умолчанию.
   */
  fun f4(str: String,
            b1: Boolean = true,
            b2: Boolean = true,
            b3: Boolean = true,
            c: Char = ' ') {
    println("str = $str, b1 = $b1, b2 = $b2, b3 = $b3, c = $c")
  }

  fun f5(s1: String = "5", s2: String = "6") { }

  // Функция с переменным количеством входных параметров
  fun f6(vararg s: String) {
    for (str in s) print("$str ")
    println()
  }

  // тоже что f7() {} или в java - void
  fun f7(): Unit {
    return Unit
  }

  fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) {
      result.add(t)
    }
    return result
  }

  infix fun f8(s: String): String {
    return "f8 " + s
  }

  fun f9() {
    var s = this f8 "d2" // вызов infix функции внутри класса
    println("f9(): s3 = $s")
    s = f8("d2") // такой вызов тоже корректен и аналогичен вызову выше
    println("f9(): s4 = $s")
  }

  /** Kotlin поддерживает локальные функции (функции внутри функций) */
  fun f10() {
    val s1 = "s1"
    fun localeF(s2: String) {
      // локальные функции могут иметь доступ к переменным,
      // расположенным в зоне видимости родительской функции
      println("s1 = $s1, s2 =$s2")
    }
    localeF("s2")
  }

  /**
   * tailrec позволяет безопасно завершить рекурсию. Если для данной
   * функции не указать ключевое слово tailrec, произойдет
   * StackOverflowError
   */
  tailrec fun f11(b: Boolean) {
    if (!b) {
      // при использовании модификатора tailrec последней опреацией
      // должен быть вызов самой рекурсивной функции. Также модификатор
      // tailrec нельзя использовать в блоках try/catch/finally
      f11(b)
    }
  }
}

